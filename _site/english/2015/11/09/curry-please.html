<p>One of the Scala's rock starts that we cannot miss the chance to speak about is currying.</p>
<p><a href="https://scalerablog.files.wordpress.com/2015/11/4252082-curry.jpg"><img class="aligncenter size-medium wp-image-805" src="/assets/4252082-curry.jpg?w=300" alt="4252082-curry" width="300" height="225" /></a></p>
<h2>What theory says</h2>
<p>If we have a function <code>(T,U) =&gt; V</code>, currying it implies decomposing the function in a simpler one that allows building the result incrementally. In that case, we would get a function <code>T =&gt; (U =&gt; V)</code>, what means that, from a <code>T</code> value we get a function whose only need is a <code>U</code> value for generating a <code>V</code> one. Messy? Let's take a better look with next example.</p>
<p>Let's suppose that we have a <code>case class</code> for modeling the student entity:</p>
<p>[code language="scala"]<br />
case class Student(<br />
  name: String,<br />
  age: Int,<br />
  enrolled: Boolean)<br />
[/code]</p>
<p>We could have a method for instantiate a student: oh wait, like method <code>apply</code>, which has been automatically generated by creating the <code>case class</code>:</p>
<p>[code language="scala"]<br />
//Auto generated code below<br />
object Student {</p>
<p>  def apply(<br />
    name: String,<br />
    age: Int,<br />
    enrolled: Boolean): Student =<br />
    new Student(name, age, enrolled)</p>
<p>}<br />
[/code]</p>
<p>By using such method, we can create a <code>Student</code> as shown below:</p>
<p>[code language="scala"]<br />
Student(&quot;john&quot;, 18, enrolled=true)<br />
[/code]</p>
<p>So easy so far. So let's imagine next requirement:</p>
<blockquote><p>In our student admission process, the candidate has to provide his/her personal data sequentially in a set of windows (At window A name must be provided. At window B so must the age. And finally, at window C, we would admit or not the candidate by setting the 'enrolled' attribute).</p></blockquote>
<h2>First approach: Classes are free!</h2>
<p>We can define our windows as type aliases of transforming functions (so redundant...). I mean:</p>
<p>[code language="scala"]<br />
type WindowA = String =&gt; NotAStudientYet<br />
type WindowB = (NotAStudentYet, Int) =&gt; AlmostAStudent<br />
type WindowC = (AlmostAStudent, Boolean) =&gt; Student</p>
<p>case class NotAStudentYet(name: String)<br />
case class AlmostAStudent(name: String, age: Int)<br />
[/code]</p>
<p>Take a look that windows are represented as functions.<br />
So first window is a function that, given a name, it generates a "not-a-student-yet-like" object.<br />
Second window takes as parameters a NotAStudientYet and the age of the subject, and it returns an "almost-a-student".<br />
And the last one takes an "almost-a-student" and an admission or rejection parameter, which will finally allow generating a Student.</p>
<p>So for our purpose, with this first approach, we have created a couple of new classes that will be used as data-accumulators for, at the end, creating a Student.</p>
<p>The implementation should look like:</p>
<p>[code language="scala"]<br />
val windowA: WindowA =<br />
  (name) =&gt;<br />
    NotAStudentYet(name)</p>
<p>val windowB: WindowB =<br />
  (notStudent, age) =&gt;<br />
    AlmostStudent(notStudent.name, age)</p>
<p>val windowC: WindowC =<br />
  (almost, enrolled) =&gt;<br />
    Student(almost.name, almost.age, enrolled)<br />
[/code]</p>
<p>...sincerely, there's no way to think that for doing such a thing, we have define additional classes. Let's try another way.</p>
<h2>Second approach: functions, functions everywhere ...</h2>
<p>Let's have a try to defining functions that return another functions (higher order functions):</p>
<p>[code language="scala"]<br />
type WindowA = String =&gt; WindowB<br />
type WindowB = Int =&gt; WindowC<br />
type WindowC = Boolean =&gt; Student</p>
<p>val windowA: WindowA =<br />
  (name: String) =&gt; {<br />
    val windowB: WindowB =<br />
      (age: Int) =&gt; {<br />
        val windowC: WindowC =<br />
          (enrolled: Boolean) =&gt;<br />
            Student(name, age, enrolled)<br />
        windowC<br />
      }<br />
    windowB<br />
  }<br />
[/code]</p>
<p>By using a bunch of little functions, we're setting values to all parameters that will build our Student. It's pretty easier if we try to read the code from the most inside function to the most outside one (first <code>windowC</code>, then <code>windowB</code> and finally <code>windowA</code>). For invoking our function it's enough with executing:</p>
<p>[code language="scala"]<br />
val student = windowA(&quot;john&quot;)(18)(true)<br />
[/code]</p>
<h2>Third approach: U sure there's nothing existing for this?</h2>
<p>Of course it is. Inside the <code>Function</code> companion object in Scala, you can find <code>curried</code> method, which purpose is to separate a function that takes N parameters, in N concatenated functions, as we were previously discussing and with the last example as well.</p>
<p>For applying this wonder to the exposed example, it's as easy as writing:</p>
<p>[code language="scala"]<br />
val f = (Sudent.apply _).curried<br />
//f: String =&gt; (Int =&gt; (Boolean =&gt; Student))</p>
<p>f(&quot;john&quot;)(18)(true)<br />
//Student(&quot;john&quot;, 18, true)<br />
[/code]</p>
<p>The reverse function called <code>uncurried</code> can also be found at the same <code>Function</code> companion object, so that N concatenated functions, for example, <code>Int =&gt; (String =&gt; (Boolean =&gt; Double)))</code> are converted to a single function that takes N different parameters: <code>(Int, String, Boolean) =&gt; Double</code>:</p>
<p>[code language="scala"]<br />
val myApply = Function.uncurried(f)<br />
//myApply: (String, Int, Boolean) =&gt; Student</p>
<p>myApply(&quot;john&quot;,18,true)<br />
//Student(&quot;john&quot;,18,true)<br />
[/code]</p>
<p>Easy peasy.<br />
Peace out! :-)</p>
