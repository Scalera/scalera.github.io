---
layout: post
title: 'Scala: One language to rule them all (II)'
date: 2016-05-30 12:00:06.000000000 +02:00
type: post
published: true
status: publish
categories:
- English
tags: []
meta:
  _oembed_0482a0514aca5d57e4cd326f75db5b4f: "{{unknown}}"
  _edit_last: '59615419'
  geo_public: '0'
  _publicize_job_id: '23323868040'
  _publicize_done_external: a:1:{s:7:"twitter";a:1:{i:10515941;s:57:"https://twitter.com/ScaleraBlog/status/737224365066964992";}}
  _publicize_done_10471757: '1'
  _wpas_done_10515941: '1'
  publicize_twitter_user: ScaleraBlog
author:
  login: pfcoperez
  email: contact@pablofranciscoperez.info
  display_name: pfcoperez
  first_name: ''
  last_name: ''
---
<p>You wouldn't put a layman under the controls of a brand new Airbus 380. Such a powerful tool requires its users to be trained; something similar happens with Scala when it is used to cast new rings of power, I mean, DSLs. Some theory and lots of <em>learning by doing.</em>  <a href="https://scalerablog.wordpress.com/2016/04/18/scala-one-language-to-rule-them-all-i/">We've already seen a bit of theory</a> and now is time to learn by building a DSL from scratch.</p>
<h1>Our DSL's target</h1>
<p>Our brand new DSL is intended to serve as an didactic exercise. However, despite of its purpose, it needs to have a target. That is (or):</p>
<ul>
<li>A process or system to govern.</li>
<li>Another language to serve as proxy of.</li>
</ul>
<p>In our example we'll tackle the second case.</p>
<h2>Introducing AWK</h2>
<p>Are you kidding? does it need introduction?<br />
Let your unix terminal introduce it for me:</p>
<p>[code language="bash"]<br />
man awk | head -n 6<br />
[/code]</p>
<blockquote><p><em>GAWK(1) Utility Commands GAWK(1)</em></p>
<p><em>NAME</em><br />
<em> gawk - pattern scanning and processing language</em></p></blockquote>
<p>OK, <a href="https://en.wikipedia.org/wiki/AWK">Wikipedia</a> seems a little more verbose:</p>
<blockquote><p><em><b>AWK</b> is an <a title="Interpreter (computing)" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreted</a> <a title="Programming language" href="https://en.wikipedia.org/wiki/Programming_language">programming language</a> designed for text processing and typically used as a <a title="Data extraction" href="https://en.wikipedia.org/wiki/Data_extraction">data extraction</a> and reporting tool. It is a standard feature of most <a title="Unix-like" href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> <a title="Operating system" href="https://en.wikipedia.org/wiki/Operating_system">operating systems</a>.</em></p>
<p><em>The AWK language is a <a title="Data-driven programming" href="https://en.wikipedia.org/wiki/Data-driven_programming">data-driven</a> <a title="Scripting language" href="https://en.wikipedia.org/wiki/Scripting_language">scripting language</a> consisting of a set of actions to be taken against <a title="Stream (computing)" href="https://en.wikipedia.org/wiki/Stream_(computing)">streams</a> of textual data – either run directly on files or used as part of a <a title="Pipeline (Unix)" href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">pipeline</a></em></p></blockquote>
<p>Consider these two heroes:</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/gnu-and-penguin-color.png"><img class="aligncenter size-medium wp-image-3389" src="{{ site.baseurl }}/assets/gnu-and-penguin-color.png?w=300" alt="Gnu-and-penguin-color" width="300" height="277" /></a></p>
<p>Gnu has a belt you can't see in this drawing and there he hides a powerful weapon: AWK.<br />
It is so powerful because it allows many scripts, running  upon (and used to build) GNU/Linux/BSD distributions, to transform, filter, aggregate,... data from other commands outputs. Let's see an example:</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/awk_sample.png"><img class="aligncenter size-full wp-image-3391" src="{{ site.baseurl }}/assets/awk_sample.png" alt="awk_sample" width="700" height="70" /></a></p>
<p>Here, the output generated by <em>lsmod </em>is piped to AWK whereby each line is processed by extracting its second column value which will be accumulated in a <em>total</em> byte counter. This way, when the output has been exhausted, <em>total</em> will be printed as the total amount of Kilo Bytes of memory used by Linux Kernel modules.</p>
<h2>A hard nut to crack?</h2>
<p>The applications of AWK are innumerable as well as the amount of time you can save once you have a grasp of it. However, for many people, it is more like...</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/6bkfb7b.png"><img class="aligncenter size-medium wp-image-3392" src="{{ site.baseurl }}/assets/6bkfb7b.png?w=300" alt="6bkFb7B" width="300" height="179" /></a></p>
<p>... than a helping tool. Its 1475 lines of <a href="https://en.wikipedia.org/wiki/Man_page" target="_blank">man</a> pages aren't precisely light reading.</p>
<p>It seem therefore that guiding an user through the composition of AWK programs could be of great help. Does this phrase ring a bell to you?</p>
<p><em><strong>DSLs</strong> are <strong>small </strong>and <strong>concise</strong> which implies that they guide their users in the process of describing actions, entities or relations within their domain of application.</em></p>
<p>Yes! A Scala internal DSL could be used to build such a tool!</p>
<h1>Hands on <del>the DSL</del> Scalawk construction</h1>
<blockquote><p><em>The most important thing in the programming language is the name...</em><br />
Donald Erving Knuth</p></blockquote>
<p>First things first and, if we take the <em>argument from authority </em>as a valid argument, we should start by giving a name to our DSL.</p>
<p>To be brief: We'll compose AWK programs by the use of a Scala internal DSL,</p>
<p style="text-align:center;">Scala + AWK = <strong>Scalawk</strong></p>
<p style="text-align:left;">So far so good!</p>
<table border="1">
<tbody>
<tr>
<td>You can already clone Scalawk source code <a href="https://github.com/pfcoperez/scalawk">GitHub</a></p>
<p>[code language="bash"]<br />
git clone https://github.com/pfcoperez/scalawk.git<br />
[/code]</td>
</tr>
</tbody>
</table>
<h2 style="text-align:left;">Divide &amp; Conquer</h2>
<p><a href="https://scalerablog.wordpress.com/2016/04/18/scala-one-language-to-rule-them-all-i/" target="_blank">In the last episode</a> we agreed that the safest way to design a DSL is by the use of the state machine model. These machines are easily decomposed into:</p>
<ul>
<li><strong>States</strong> (one of them is the machine initial state).</li>
<li><strong>Transitions</strong>:
<ul>
<li>Inputs triggering the transition.</li>
<li>Transition effects:
<ul>
<li>The machine changes its current state.</li>
<li>Some output could be generated besides the state transition.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Machine alphabet</strong>: Machine input entities.</li>
</ul>
<p>By drawing the state machine diagram, which is not different from designing an interactive guide, we'll complete the whole creative process in the creation of the DSL. The remaining work isn't more than beautiful Scala boilerplate.</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/machine.png"><img class="aligncenter size-full wp-image-3393" src="{{ site.baseurl }}/assets/machine.png" alt="machine" width="361" height="553" /></a></p>
<p>All possible users interaction with Scalawk are represented in the previous graph, e.g:</p>
<p>[code language="scala"]<br />
lines splitBy &quot;;&quot; arePresentedAs ('c1, 'c2)<br />
[/code]</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/machine_walkthrough.png"><img class="aligncenter size-full wp-image-3394" src="{{ site.baseurl }}/assets/machine_walkthrough.png" alt="machine_walkthrough" width="451" height="553" /></a></p>
<p>This machine modelling and decomposition leads to the following Scala packages structure:</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/packages.png"><img class="aligncenter size-full wp-image-3395" src="{{ site.baseurl }}/assets/packages.png" alt="packages" width="187" height="75" /></a></p>
<h2>The nuts &amp; bolts or: How I Learnt to Stop Worrying and Love the Building Blocks that Scala Provides</h2>
<p>States, transitions and auxiliary elements are entities contained by the packages listed above. In fact, they are nothing but Scala objects, classes, methods and traits.</p>
<h3>Initial State</h3>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/initial_state.png"><img class="aligncenter size-full wp-image-3396" src="{{ site.baseurl }}/assets/initial_state.png" alt="initial_state" width="92" height="71" /></a></p>
<p>As <a href="https://scalerablog.wordpress.com/2016/04/18/scala-one-language-to-rule-them-all-i/" target="_blank">we already know</a>,  states are objects. Either they are instances of classes or singleton objects. On the other hand, we've also seen that the right way to implement state machines is to make these states immutable, being transitions responsible for new states generation.</p>
<p>The initial state ins't generated by any transition, it exists as it is from the beginning of the program. That is a good indicator of its singleton nature which is definitely confirmed by the fact that no other instance of this initial state can exist:</p>
<p>[code language="scala"]<br />
object lines extends ToCommandWithSeparator<br />
[/code]</p>
<p>From the DSL user standpoint, this initial state should be just a word indicating the start of a phrase in the language. That's another reason supporting the singleton object approach.</p>
<p>The initial state need to transit to the next one, that's is why <em>lines </em>is extending <em>ToCommandWithSeparator </em>. Don't rush, but keep in mind that <em>ToCommandWithSeparator </em>is <strong>transition set trait</strong>.</p>
<h3>Transitory and final states</h3>
<p>Yeah, states are objects... is that all? No!  There are different kinds of states, besides, many states are quite alike and they could be built from templates. Lets review some tricks and tips.</p>
<p>The top-level classification of non-initial states should be this one: <strong>Transitory</strong> and <strong>final</strong>. Conceptually, the former can't be used to generate a result whereas the latter can. In the concrete case of Scalawk that implies that transitory states can't generate valid AWK programs but final states can.</p>
<p>[caption id="attachment_3397" align="aligncenter" width="107"]<a href="https://scalerablog.files.wordpress.com/2016/05/with_initialprogram_st.png"><img class="aligncenter  wp-image-3397" src="{{ site.baseurl }}/assets/with_initialprogram_st.png" alt="with_initialprogram_st" width="107" height="76" /></a> <a href="https://scalerablog.files.wordpress.com/2016/05/with_initialprogram_st.png">Non-final state<br /></a>[/caption]</p>
<p>[caption id="attachment_3398" align="aligncenter" width="114"]<img class="  wp-image-3398 aligncenter" src="{{ site.baseurl }}/assets/solidcomand_st.png" alt="solidcomand_st" width="114" height="74" /> Final state[/caption]</p>
<p>In Scalawk, any entity able to generate valid AWK code should mix <em>AwkElement</em></p>
<p>[code language="scala"]<br />
trait AwkElement {<br />
  def toAwk: String<br />
}<br />
[/code]</p>
<p>By doing so, we are adding <em>toAwk </em>method to that entity, the entry point to ask for AWK code from client code.</p>
<p>Despite of their differences, almost all states share a common set of attributes from which AWK commands can be composed:</p>
<ul>
<li><strong>Command line options</strong>, e.g: <em>Token separator</em></li>
<li><strong>Initial program: </strong>Instructions to be run by AWK before starting line processing. e.g: Initialize<em> a counter value</em>.</li>
<li><strong>Line program:</strong> Instructions to be executed for each line of the AWK input. e.g: <em>Printing a line; adding a value to an accumulator initialized at the Initial Program.</em></li>
<li><strong>End program:</strong> Instructions to be executed after all lines have been processed, that is, after <em>Line Program </em>has been run using each single input line as its own input. e.g: <em>Printing counters values.</em></li>
</ul>
<p>At each state, these fields might be empty or not and when a final state is asked to produce an AWK program, they will be used to generate the result string value.</p>
<p>[code language="scala"]<br />
abstract class AwkCommand protected(<br />
  private[scalawk] val commandOptions: Seq[String] = Seq.empty,<br />
  private[scalawk] val linePresentation: Seq[AwkExpression] = Seq.empty,<br />
  private[scalawk] val lineProgram: Seq[SideEffectStatement] = Seq.empty,<br />
  private[scalawk] val initialProgram: Seq[SideEffectStatement] = Seq.empty,<br />
  private[scalawk] val endProgram: Seq[SideEffectStatement] = Seq.empty<br />
) {<br />
  def this(prev: AwkCommand) = this(<br />
    prev.commandOptions,<br />
    prev.linePresentation,<br />
    prev.lineProgram,<br />
    prev.initialProgram,<br />
    prev.endProgram<br />
  )<br />
}<br />
[/code]</p>
<p>So far, we know that non-initial states:</p>
<ul>
<li>For sure, contain the building blocks of a result and propagate the previous state contents for these fields:  <strong>Then they should extend <em>AwkCommand </em>abstract class.</strong></li>
<li>Most probably, add or change some piece of information from the previous state <em>AwkCommand </em>attributes: <strong>Then they should override <em>AwkCommand </em>attributes.</strong></li>
<li>Optionally, can <strong>transit</strong> to another state: If it is the case, they should have a method with the type of the target state as return value or mix  a transition family trait.</li>
</ul>
<p>You might be thinking: <em>Why is AwkCommand an abstract class and not a trait?<br />
</em>Well, <em>AwkCommand</em>'s <strong>goal is to provide a re-usable code for continuity</strong>. That is, it provides the constructor to build a state from another state (<em>prev </em>parameter). This way, states code is reduced to just their transitions and <em>AwkCommand </em>attribute overrides but <strong>only for those attributes whose information is changing in the new state.</strong></p>
<p>Obviously, the only way to provide a constructor in a class hierarchy is by providing a class, if this class can't be instantiated: Make it abstract.</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/abstract_with_constructor.jpg"><img class="aligncenter size-medium wp-image-3399" src="{{ site.baseurl }}/assets/abstract_with_constructor.jpg?w=300" alt="abstract_with_constructor" width="300" height="300" /></a></p>
<p>[code language="scala"]<br />
class CommandWithLineProgram(<br />
                              statements: Seq[SideEffectStatement]<br />
                            )(prev: AwkCommand) extends AwkCommand(prev)<br />
  with ToSolidCommand {</p>
<p>  override private[scalawk]val lineProgram: Seq[SideEffectStatement] = statements</p>
<p>}<br />
[/code]</p>
<p><em>CommandWithLineProgram</em> is a non-final state hence it doesn't mix <em>AwkElement </em>trait.</p>
<p>[code language="scala"]<br />
//This is the first state which can be used to obtain an AWK command string `toAwk`<br />
class SolidCommand(val lineResult: Seq[AwkExpression], prevSt: AwkCommand) extends AwkCommand(prevSt)<br />
  with AwkElement<br />
  with ToCommandWithLastAction {<br />
 ...<br />
 ...<br />
 ...<br />
}<br />
[/code]</p>
<p>On the contrary, <em>SolidCommand </em>does<em>,</em> therefore needs to provide an implementation to <em>toAwk </em>method:</p>
<p>[code language="scala"]<br />
 // AWK Program sections</p>
<p>// BEGIN<br />
protected def beginBlock: String = programToBlock(initialProgram)</p>
<p>// Per-line<br />
protected def eachLineActionBlock: String =<br />
programToBlock(lineProgram ++ linePresentation.headOption.map(_ =&gt; Print(linePresentation)))</p>
<p>// END<br />
protected def endBlock: String = programToBlock(endProgram)</p>
<p>protected def programToBlock(program: Seq[SideEffectStatement]) =<br />
{program.map(_.toAwk) mkString &quot;; &quot;} +<br />
program.headOption.map(_ =&gt; &quot;; &quot;).getOrElse(&quot;&quot;)</p>
<p>protected def optionsBlock: String =<br />
{commandOptions mkString &quot; &quot;} + commandOptions.headOption.map(_ =&gt; &quot; &quot;).getOrElse(&quot;&quot;)</p>
<p>override def toAwk: String =<br />
s&quot;&quot;&quot;|awk ${optionsBlock}'<br />
|${identifyBlock(&quot;BEGIN&quot;, beginBlock)}<br />
|${identifyBlock(&quot;&quot;, eachLineActionBlock)}<br />
|${identifyBlock(&quot;END&quot;, endBlock)}'&quot;&quot;&quot;.stripMargin.replace(&quot;\n&quot;, &quot;&quot;)</p>
<p>//Auxialiary methods<br />
private[this] def identifyBlock(blockName: String, blockAwkCode: String): String =<br />
blockAwkCode.headOption.map(_ =&gt; s&quot;$blockName{$blockAwkCode}&quot;).getOrElse(&quot;&quot;)<br />
[/code]</p>
<p>This class hierarchy enables code re-utilization, for example, <em>SolidCommandWithLastAction</em> is almost an exact copy of <em>SolidCommand</em> and nothing prevents us from extending it in order to define <em>SolidCommandWithLastAction:</em></p>
<p>[code language="scala"]<br />
class SolidCommandWithLastAction(lastAction: Seq[SideEffectStatement])(prevSt: SolidCommand)<br />
extends SolidCommand(prevSt) {...}<br />
[/code]</p>
<p>At this point, you should be able to start exploring <a href="https://github.com/pfcoperez/scalawk">the repository</a> as well as to associate each state from the graph diagram with a state class in the code. Just in case, the following table collect these associations:</p>
<table class="c2">
<tbody>
<tr class="c7">
<td class="c0" colspan="1" rowspan="1">
<p class="c6"><strong><span class="c11">Graph Node</span></strong></p>
</td>
<td class="c5" colspan="1" rowspan="1">
<p class="c6"><strong><span class="c11">Entity</span></strong></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><strong><span class="c11">Is final state?</span></strong></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><strong><span class="c11">Entity Kind</span></strong></p>
</td>
</tr>
<tr class="c7">
<td class="c0" colspan="1" rowspan="1">
<p class="c6"><span class="c1">init</span></p>
</td>
<td class="c5" colspan="1" rowspan="1">
<p class="c6"><span class="c9">lines</span></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><span class="c1">No</span></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Singleton Object</span></p>
</td>
</tr>
<tr class="c7">
<td class="c0" colspan="1" rowspan="1">
<p class="c6"><span class="c1">command</span></p>
</td>
<td class="c5 c10" colspan="1" rowspan="1">
<p class="c6"><span class="c10 c14">CommandWithSeparator</span></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><span class="c1">No</span></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Class</span></p>
</td>
</tr>
<tr class="c7">
<td class="c0" colspan="1" rowspan="1">
<p class="c6"><span class="c1">with line program</span></p>
</td>
<td class="c5" colspan="1" rowspan="1">
<p class="c6"><span class="c9">CommandWithLineProgram</span></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><span class="c1">No</span></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Class</span></p>
</td>
</tr>
<tr class="c7">
<td class="c0 c10" colspan="1" rowspan="1">
<p class="c6"><span class="c10 c13">with initial program</span></p>
</td>
<td class="c5" colspan="1" rowspan="1">
<p class="c6"><span class="c9">CommandWithInitialProgram</span></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><span class="c1">No</span></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Class</span></p>
</td>
</tr>
<tr class="c7">
<td class="c0" colspan="1" rowspan="1">
<p class="c6"><span class="c1">solid command</span></p>
</td>
<td class="c5" colspan="1" rowspan="1">
<p class="c6"><span class="c9">SolidCommand</span></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Yes</span></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Class</span></p>
</td>
</tr>
<tr class="c7">
<td class="c0" colspan="1" rowspan="1">
<p class="c6"><span class="c1">with last action</span></p>
</td>
<td class="c5" colspan="1" rowspan="1">
<p class="c6"><span class="c9">SolidCommandWithLastAction</span></p>
</td>
<td class="c8" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Yes</span></p>
</td>
<td class="c3" colspan="1" rowspan="1">
<p class="c6"><span class="c1">Class</span></p>
</td>
</tr>
</tbody>
</table>
<h3></h3>
<h3>Transitions</h3>
<p>Transitions between states are the easy part, they are as simple as methods returning new states. Thanks to Scala infix notation they create the illusion of natural language expressions, at least to some degree...</p>
<p>Some states might share transitions so it seems a good a idea to create traits containing them. By the use of mixing, states can thus use them as LEGO pieces in order to build their own transition set.</p>
<p>There are two special cases which deserve special attention: <strong>Groups of transitions </strong>and<strong> Empty input transitions</strong>.</p>
<h4>Group of transitions...</h4>
<p>... are composed by transitions which are always present together or which are different versions of the same transition. These are normally defined at the same trait named following the pattern <em>To&lt;STATE_CLASS_NAME&gt;.</em></p>
<p>[code language="scala"]<br />
trait ToCommandWithSeparator {</p>
<p>  def splitBy(separator: String) = new CommandWithSeparator(separator)<br />
  def splitBy(separator: Regex) =  new CommandWithSeparator(separator)</p>
<p>}<br />
[/code]</p>
<p>The example above is a rather clear case of two versions of the same transition: One receiving a string input and the other receiving a regular expression.</p>
<p><span style="color:#ff0000;"><strong>Note that</strong></span>, in relation with the abstract state machine, the machine input is both the method name and its parameters.</p>
<h4>Empty input transitions</h4>
<p>Consider the following transition, extracted from our state machine:</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/empty_transition.png"><img class="aligncenter size-full wp-image-3400" src="{{ site.baseurl }}/assets/empty_transition.png" alt="empty_transition" width="249" height="70" /></a></p>
<p>State machines can move from one state to another when the input is an empty string. It might seem bizarre but it can be done with our object modelling of state machines thanks to <a href="http://orionsword.no-ip.org/blog/wordpress/?p=600" target="_blank">implicit conversions</a>.</p>
<p>An implicit conversion from a state (Source) to another (Target) by just trying to access one of T<em>arget </em>methods having a S<em>ource </em>instance will be perceived by the DSL user as an empty transition. As simply as it sounds.</p>
<p>What is more, by just defining the implicit conversion at the companion object of either the <em>Source </em>or <em>Target </em>class/trait, it will be available in the scope of the sentence where the empty transition occurs. No need of imports which means: ABSOLUTELY TRANSPARENCY for the user.</p>
<p>Thus, the following code:</p>
<p>[code language="scala"]<br />
object ToCommandWithSeparator {<br />
  implicit def toCommandWithSep(x: ToCommandWithSeparator) = new CommandWithSeparator()<br />
}<br />
[/code]</p>
<p>... enables the transition described in the diagram below:</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/empty_transition2.png"><img class="aligncenter size-full wp-image-3401" src="{{ site.baseurl }}/assets/empty_transition2.png" alt="empty_transition2" width="203" height="71" /></a></p>
<blockquote><p><img class="  wp-image-3944 aligncenter" src="{{ site.baseurl }}/assets/vvqnk6o.jpg" alt="VvqNk6o" width="385" height="290" /></p>
<p>- If <em>ToCommandWithSeparator</em> is a transition family trait, isn't its equally named companion object the companion object of that transition family? Didn't we set that the implicit conversion should be defined within <em>Source </em>or <em>Target</em>'s companion object and, therefore, within a state class?</p>
<p>- Exactly! And what's <em>ToCommandWithSeparator</em>'s fate if not to be mixed at a state class definition?</p></blockquote>
<p>In Scala, implicit conversions defined at a trait companion object will also apply for those classes extending or mixing that trait and they'll be available on any scope where that class is available. This feature, besides being extremely useful, seems to be a very rational one: The class mixing/extending the trait can be regarded as a kind-of that trait, a subtype, so any of its instances are also of the type given by the trait and it should be expected that any conversion applying to that type could also apply to these instances.</p>
<p>Take, for example, the traits <em>T </em>and <em>S </em>, both having companion objects where implicit conversions to <em>D </em>and <em>E </em>are respectively defined:</p>
<p>[code language="scala"]<br />
case class E(x: Int)<br />
case class D(x: Int)</p>
<p>trait T<br />
object T { implicit def toD(from: T): D = D(1) }</p>
<p>trait S<br />
object S { implicit def toE(from: S): E = E(2) }<br />
[/code]</p>
<p>Mix both of them in the definition of the class <em>C</em>...</p>
<p>[code language="scala"]<br />
case class C() extends T with S<br />
[/code]</p>
<p>... and check how a <em>C</em> instance is implicitly converted into instances of <em>E</em> or <em>D</em>.</p>
<p>[code language="scala"]<br />
scala&gt; val c: C = C()<br />
c: C = C()</p>
<p>scala&gt; val d: D = c<br />
d: D = D(1)<br />
scala&gt; val e: E = c<br />
e: E = E(2)<br />
[/code]</p>
<h3>Expressions</h3>
<p>Most Scalawk transition inputs fit into the pattern <em>transition name + basic type value. </em>However, some of them receive expressions, identifiers or sentences. These are particular types created to express instructions and values within the AWK program. Hence they should not be part of a generic guide on how to create a DSL. Yet, the constructs behind them are not uncommon in many Scala Internal DSLs so we'll take a brief look at some of them.</p>
<h4>Identifiers in Scalawk (Internal Identifiers)</h4>
<p>Some DSL expressions, such as <em>arePresentedAs, </em>need to make reference to AWK variables, declared by some other DSL expression. You could use strings to represent these internal identifiers. But having to surround our DSL identifiers in double quotes throws a bucket of cold water on its user experience, making the user conscious of the fact that she/he is actually using Scala instead of a crafted-from-scratch domain language.</p>
<p>Scala offers a mechanism to <em><a href="http://www.scala-lang.org/api/2.11.8/#scala.Symbol">get unique objects for equal strings</a></em>. That is exactly what a good DSL identifier needs.</p>
<p>If anyone writes:</p>
<p>[code language="scala"]<br />
'counter<br />
[/code]</p>
<p>... her/he will be obtaining a reference to a <em>Symbol </em>instance.  <em>Symbol </em>class has a <em>name </em>attribute whereby you can recover the character string used to obtain the instance.</p>
<p>The user would just write <em>'counter </em>and the DSL developer can obtain the string <em>counter</em> and use it for the internal representation of, in this case, the AWK variable.</p>
<h4>Sentences</h4>
<p>By combining internal identifiers with ad-hoc classes and implicit conversions it isn't difficult to express assignation sentences, event algebraic operations.</p>
<p>[code language="scala"]<br />
's := 's + 1<br />
[/code]</p>
<p>This article is already far too long and with what has been hinted and the tricks of previous sections it is actually easy to understand the code to build this kind of expressions. That code is located under <a href="https://github.com/pfcoperez/scalawk/tree/master/src/main/scala/org/pfcoperez/scalawk/entities"><em>entities </em>package</a>.  Take that package as if it were a embedded DSL within Scalawk, yes, a DSL embedded in a DSL which is in turn embedded in Scala.</p>
<h1>Some final thoughts</h1>
<p>Developing internal DSLs isn't precisely a piece of cake. If being forced to fall back to the host language constructs, users will easily wake up from the dream of being using a language built for them from the ground up. Nobody likes to be reminded he/her is not that special.</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/scala_has_you.png"><img class="aligncenter size-full wp-image-3402" src="{{ site.baseurl }}/assets/scala_has_you.png" alt="scala_has_you" width="384" height="113" /></a></p>
<p>You'll encounter many pitfalls when trying to faithfully reproduce the state machine, the temptation to abandon the model is huge. Trust me, this is complex and, if you leave the path of the state machine, the ogres in the forest will have your heart for breakfast sooner than you imagine. Scala has proven it can offer a solution to any bump of the state machine road, outside that road you are free to face a minefield.</p>
<p>As a last piece of advice, I'd recommend you to buy a white/black board, a paper notebook and a good pen... whatever you feel confortable to draw on.</p>
<p>These are two examples of the early stages of design of Scalawk:</p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/whiteboard.jpg"><img class="aligncenter size-medium wp-image-3403" src="{{ site.baseurl }}/assets/whiteboard.jpg?w=225" alt="whiteboard" width="225" height="300" /></a></p>
<p><a href="https://scalerablog.files.wordpress.com/2016/05/notebook.jpg"><img class="aligncenter size-medium wp-image-3404" src="{{ site.baseurl }}/assets/notebook.jpg?w=238" alt="notebook" width="238" height="300" /></a></p>
<p>Think! draw! think! and draw again! so you are a better DSL architect than this guy...<br />
<a href="https://scalerablog.files.wordpress.com/2016/05/be-21-architect.jpg"><img class="aligncenter  wp-image-3405" src="{{ site.baseurl }}/assets/be-21-architect.jpg?w=300" alt="BE-21-architect" width="388" height="219" /></a></p>
<p>... so your Neo(s) wouldn't wake so easily.</p>
